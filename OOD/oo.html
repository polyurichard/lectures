<!DOCTYPE html>
<html>
<head>
<title>oo.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<ul>
<li><a href="#introduction-to-object-oriented-design">Introduction to Object-Oriented Design</a>
<ul>
<li><a href="#define-the-player-class">Define the Player Class</a></li>
<li><a href="#uml-diagram">UML Diagram</a></li>
</ul>
</li>
<li><a href="#fundamental-oo-concepts">Fundamental OO Concepts</a>
<ul>
<li><a href="#encapsulation">Encapsulation</a></li>
<li><a href="#inheritance">Inheritance</a></li>
<li><a href="#interface">Interface</a></li>
<li><a href="#abstraction">Abstraction</a></li>
<li><a href="#composition-and-delegation">Composition and Delegation</a></li>
<li><a href="#program-to-an-interface">Program to an interface</a></li>
<li><a href="#polymorphism">Polymorphism</a></li>
<li><a href="#uml-class-diagrams">UML Class Diagrams</a></li>
<li><a href="#abstract-class">Abstract class</a></li>
</ul>
</li>
<li><a href="#the-solid-principle">The SOLID Principle</a>
<ul>
<li><a href="#single-responsibility-principle-srp">Single Responsibility Principle (SRP)</a></li>
<li><a href="#openclosed-principle-ocp">Open/Closed Principle (OCP)</a></li>
<li><a href="#liskov-substitution-principle-lsp">Liskov Substitution Principle (LSP)</a></li>
<li><a href="#interface-segregation-principle-isp">Interface Segregation Principle (ISP)</a></li>
<li><a href="#dependency-inversion-principle-dip">Dependency Inversion Principle (DIP)</a>
<ul>
<li><a href="#saving-the-game">Saving the game</a></li>
<li><a href="#cohesion-vs-coupling">Cohesion vs. Coupling</a></li>
<li><a href="#dependency-inversion-principle-dip-1">Dependency Inversion Principle (DIP)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#additional-topics-related-to-oo">Additional topics related to OO</a>
<ul>
<li><a href="#multiple-inheritance">Multiple Inheritance</a></li>
<li><a href="#inheritance-and-its-problems">Inheritance and Its Problems</a></li>
<li><a href="#using-interface-to-model-behaviors">Using Interface to model behaviors</a></li>
<li><a href="#testing-with-mock-objects">Testing with Mock objects</a>
<ul>
<li><a href="#inversion-of-control-ioc-container">Inversion of Control (IoC) container</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="introduction-to-object-oriented-design">Introduction to Object-Oriented Design</h1>
<p>Object-Oriented Design (OOD) is a programming paradigm that uses &quot;objects&quot; to design applications and computer programs. This results in more flexible and maintainable software.</p>
<p>In this lecture, we will learn about different Object-Oriented (OO) concepts using an RPG game as an example.</p>
<h2 id="define-the-player-class">Define the Player Class</h2>
<p>Classs and  Objects are fundamental concepts in OO design.</p>
<ul>
<li>A <strong>Class</strong> is a blueprint for an object.</li>
<li>An <strong>Object</strong> is an entity that contains both data and behavior.</li>
</ul>
<p>Let's consider the <code>Player</code> class in the RPG game. The <code>Player</code> class in the RPG game serves as a blueprint for creating player objects in the game. It encapsulates the properties and behaviors that are common to all players.</p>
<p><strong>Attributes</strong> represent the properties/state of an object. In the case of the <code>Player</code> class, there are several attributes such as <code>name</code>, <code>health</code>, and <code>score</code> that define the properties or the state of a Player object.</p>
<ul>
<li><code>name</code>: A String representing the player's name.</li>
<li><code>health</code>: An integer value representing the player's health.</li>
<li><code>score</code>: An integer value representing the player's score.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> health;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> score;
}
</div></code></pre>
<p><strong>Methods</strong>: Methods define the behavior of an object, detailing what the object can do.</p>
<ul>
<li>In the <code>Player</code> class, methods like <code>increaseScore</code> alter the object's state or interact with other objects.</li>
<li><strong>Setter Methods</strong>: These methods are used to modify the state of an object. E.g. The <code>setName(String name)</code> method in the Player class is a setter method that allows you to change the player's name.</li>
<li><strong>Getter Method</strong>: The getter method is used to access the value of a private field. In this class, <code>getName()</code> is a getter method that returns the value of the name field.</li>
<li>The <code>useWeapon</code> method is an example of a behavior that a Player object can perform (e.g. allow the Player object to use a weapon)</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> health;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> score;

    <span class="hljs-comment">// Constructor </span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Player</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.health = <span class="hljs-number">100</span>; <span class="hljs-comment">// Default health for a new player</span>
        <span class="hljs-keyword">this</span>.score = <span class="hljs-number">0</span>; <span class="hljs-comment">// Default score for a new player</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increaseScore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> points)</span> </span>{
        score += points;
    }

  <span class="hljs-comment">// Getter methods</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-comment">// Setter methods</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-comment">//other methods ...</span>
}
</div></code></pre>
<p>A <code>constructor</code> is a special method that is invoked when an object of a class is instantiated. It is used to initialize the attributes of the class. The <code>Player</code> constructor, for example, initializes the player's name, health, and score.</p>
<p>An <code>object</code> is an instance of a class, containing the attributes and methods defined in the class. To create a <code>Player</code> object, we simply instantiate the class with the new keyword:</p>
<pre class="hljs"><code><div>Player player1 = <span class="hljs-keyword">new</span> Player(<span class="hljs-string">"Alice"</span>);
Player player2 = <span class="hljs-keyword">new</span> Player(<span class="hljs-string">"Bob"</span>);
</div></code></pre>
<p>Methods allow for the manipulation and interaction with an object's data. In Java, object methods are invoked using the &quot;dot&quot; notation. Example</p>
<pre class="hljs"><code><div>String name = player1.getName() <span class="hljs-comment">//get the player's name</span>
player1.increaseScore(<span class="hljs-number">10</span>); <span class="hljs-comment">//increases player1's score by 10</span>
</div></code></pre>
<h2 id="uml-diagram">UML Diagram</h2>
<p><img src="image-20.png" alt="Alt text">
The UML diagram visually represents the structure of the <code>Player</code> class, including its attributes, constructor, methods, and their signatures. The class is represented as a rectangle divided into three sections.</p>
<ul>
<li>The top section contains the name of the class (<code>Player</code> in this case).</li>
<li>The middle section contains the attributes (<code>name</code>, <code>health</code>, and <code>score</code>) with their corresponding types.
<ul>
<li>The <code>-</code> symbol before the attribute names (<code>name</code>, <code>health</code>, and <code>score</code>) indicates that they are private, meaning they can only be accessed within the class itself.</li>
<li>The <code>+</code> symbol before the method names (<code>Player(String)</code>, <code>increaseScore(int)</code>, <code>getName()</code>, etc) indicates that they are public, meaning they can be accessed from other classes.</li>
</ul>
</li>
<li>The bottom section shows the methods in the class
<ul>
<li>The <code>()</code> after the method names indicates that they are methods (functions) of the class.</li>
<li>The <code>String</code>, <code>int</code>, and other data types represent the types of attributes and return types of methods.</li>
<li>The <code>: String</code> after <code>getName()</code> indicates that the return type of the method is <code>String</code>.</li>
<li>The parameters of the methods (<code>String name</code> in <code>Player(String)</code>, <code>int points</code> in <code>increaseScore(int)</code>, etc) indicate the input values that can be passed to the methods when they are called.</li>
</ul>
</li>
</ul>
<hr>
<h1 id="fundamental-oo-concepts">Fundamental OO Concepts</h1>
<h2 id="encapsulation">Encapsulation</h2>
<p>Encapsulation is a fundamental principle of object-oriented programming that restricts direct access to an object's attributes. It avoids  the data and code being tied together within an object from being randomly accessed by other code defined outside the object or class.</p>
<p><img src="image-9.png" alt="Alt text">
The <code>Monster</code> class represents a monster in the game. It  includes attributes like <code>name</code> and <code>health</code>, and methods to manage these attributes.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monster</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> health;

    <span class="hljs-comment">// Constructor</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Monster</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> health)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.health = health;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">takeDamage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>{
        health -= amount;
        <span class="hljs-keyword">if</span> (health &lt; <span class="hljs-number">0</span>) {
            health = <span class="hljs-number">0</span>;
        }
    }

    <span class="hljs-comment">// Getters</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHealth</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> health;
    }
}
</div></code></pre>
<p>Let's instantiate three monsters from the <code>Monster</code> class.</p>
<pre class="hljs"><code><div>Monster goblin1 = <span class="hljs-keyword">new</span> Monster(<span class="hljs-string">"Goblin"</span>, <span class="hljs-number">50</span>);
Monster goblin2 = <span class="hljs-keyword">new</span> Monster(<span class="hljs-string">"Goblin"</span>, <span class="hljs-number">50</span>);
Monster orc1 = <span class="hljs-keyword">new</span> Monster(<span class="hljs-string">"Orc"</span>, <span class="hljs-number">100</span>);
</div></code></pre>
<p>Here are the three types of visibility modifiers in Java:</p>
<ol>
<li><strong>Public</strong>: The public modifier allows the attribute or method to be accessed from anywhere, even outside the class.</li>
<li><strong>Private</strong>: The private modifier restricts access to the attribute or method to within the class itself.</li>
<li><strong>Protected</strong>: The protected modifier allows access to the attribute or method within the class itself and any subclasses of the class.</li>
<li><strong>Default</strong>: If no visibility modifier is specified, the attribute or method is accessible within the class itself and any other class in the same package.</li>
</ol>
<p>In the <code>Monster</code> class, the <code>name</code> and <code>health</code> variables are declared as private, which means they cannot be accessed directly from outside the class.</p>
<p>For instance, the following statement will generate compilation errors.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Monster goblin = <span class="hljs-keyword">new</span> Monster(<span class="hljs-string">"Goblin"</span>, <span class="hljs-number">50</span>);
        goblin.health = -<span class="hljs-number">30</span>; <span class="hljs-comment">// Error: name has private access in Monster</span>
    }
}
</div></code></pre>
<p>By making the visibility of the variable <code>health</code> private, it cannot be directly accessed or modified from outside the class. This prevents the <code>health</code> from being set to an invalid value (e.g. negative number) accidentally.</p>
<p>Public methods are provided to allow controlled access to the private attributes.</p>
<ul>
<li>For instance, the <code>getName()</code> and <code>getHealth()</code> methods allow external code to access the <code>name</code> and <code>health</code> attributes of a <code>Monster</code> object.</li>
<li>The <code>takeDamage(int amount)</code> method is a public method that allows external code to interact with the <code>health</code> attribute in a controlled way. It reduces the <code>health</code> by the amount specified, but also ensures that <code>health</code> cannot go below 0.</li>
</ul>
<h2 id="inheritance">Inheritance</h2>
<p>Inheritance is a mechanism in Java that allows one class to acquire the properties (fields) and behaviors (methods) of another class.</p>
<ul>
<li>The class which inherits the properties of another class is known as the <strong>subclass</strong> (or derived class, child class)</li>
<li>The class whose properties are inherited is known as the <strong>superclass</strong> (or base class, parent class).</li>
</ul>
<p><img src="image-8.png" alt="Alt text"></p>
<p>Let's Create a new class named <code>Warrior</code> that extends <code>Player</code>.</p>
<ul>
<li>The <code>Warrior</code> class inherits all the public and protected members (fields and methods) of the <code>Player</code> class.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Warrior</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Player</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> armor;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Warrior</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> armor)</span> </span>{
        <span class="hljs-keyword">super</span>(name);
        <span class="hljs-keyword">this</span>.armor = armor;
    }
}
</div></code></pre>
<p>We may add new methods that are specific to a <code>Warrior</code>. For example, a Warrior might have a method to <code>attack</code> with a sword.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Warrior</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Player</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> armor;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Warrior</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> armor)</span> </span>{
        <span class="hljs-keyword">super</span>(name);
        <span class="hljs-keyword">this</span>.armor = armor;
    }

    <span class="hljs-comment">//getter and setter methods ...</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attackWithSword</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// Implementation of attackWithSword</span>
    }
}
</div></code></pre>
<p>Inheritance promotes reusability by allowing you to reuse code that's already been tested and debugged.</p>
<p>For instance, let's consider the <code>Warrior</code> class that extends the <code>Player</code> class in our game.</p>
<ul>
<li>The <code>Player</code> class might have attributes like <code>name</code>, <code>health</code>, and <code>weapon</code>, and methods to manage these attributes and perform actions like <code>attack()</code>.</li>
<li>When we create the <code>Warrior</code> class, we don't have to write all this code again. Instead, we can simply extend the <code>Player</code> class, and the <code>Warrior</code> class will automatically have all the attributes and methods of the <code>Player</code> class. This promotes reusability.</li>
</ul>
<hr>
<p><strong>Exercise</strong>:
Define the <code>Mage</code> Class:</p>
<ol>
<li>The <code>Mage</code> class should extend the <code>Player</code> class.</li>
<li>Add a new attribute <code>mana</code> (int) to represent the mage's magic energy.</li>
<li>Add a constructor that takes <code>name</code> and <code>mana</code> as parameters and initializes these attributes along with the attributes from the <code>Player</code> class.</li>
<li>Add getter and setter methods for <code>mana</code>.</li>
<li>Add a method <code>castSpell()</code> that represents the mage casting a spell. The implementation can be simple, such as printing a message.</li>
</ol>
<!--
**Sample solution**:

```java
public class Mage extends Player {
    private int mana;

    public Mage(String name, int mana) {
        super(name);
        this.mana = mana;
    }

    public int getMana() {
        return mana;
    }

    public void setMana(int mana) {
        this.mana = mana;
    }

    public void castSpell() {
        if (mana > 0) {
            System.out.println(getName() + " casts a spell!");
            mana--;
        } else {
            System.out.println(getName() + " is out of mana!");
        }
    }
}
```
-->
<h2 id="interface">Interface</h2>
<p>An interface in OO defines a contract that a class agrees to follow. The purpose of an interface is to specify a contract or behavior that classes can implement.</p>
<ul>
<li>An interface can provide <em>no implementation</em> at all.</li>
<li>Interface does not include any attributes
<ul>
<li>Interfaces in Java are used to declare methods that a class must implement, not to define the state of an object.</li>
</ul>
</li>
</ul>
<p><img src="image-11.png" alt="Alt text">
Let's begin by defining a  <code>Weapon</code> interface with <code>use</code> and <code>upgrade()</code> methods.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Weapon</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">upgrade</span><span class="hljs-params">()</span></span>;
}
</div></code></pre>
<p>We will implement the <code>Weapon</code> interface in two distinct classes: <code>Bow</code> and <code>Sword</code>.</p>
<p>The <code>Bow</code> class includes methods <code>upgrade()</code>, <code>use()</code>, and <code>reload()</code>.</p>
<ul>
<li><code>upgrade()</code>: Increases the bow's damage and provides feedback.</li>
<li><code>use()</code>: Simulates the action of shooting an arrow.</li>
<li><code>reload()</code>: Restocks the bow with arrows.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bow</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Weapon</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> damage;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> arrows; 
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-comment">// Constructor and other methods ...</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">upgrade</span><span class="hljs-params">()</span> </span>{
        damage += <span class="hljs-number">10</span>; 
        System.out.println(name + <span class="hljs-string">" has been upgraded"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"Shooting an arrow"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reload</span><span class="hljs-params">()</span> </span>{
        arrows = <span class="hljs-number">10</span>; <span class="hljs-comment">// Reloads the bow with 10 arrows</span>
    }
}
</div></code></pre>
<p>The <code>Sword</code> class includes methods <code>upgrade()</code> and <code>use()</code>.</p>
<ul>
<li><code>upgrade()</code>: Increases the sword's damage and provides feedback.</li>
<li><code>use()</code>: Simulates the action of swinging the sword.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sword</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Weapon</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> damage;
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-comment">// Constructor and other methods ...</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">upgrade</span><span class="hljs-params">()</span> </span>{
        damage += <span class="hljs-number">15</span>; 
        System.out.println(name + <span class="hljs-string">" has been upgraded."</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"Swinging the sword"</span>);
    }
}
</div></code></pre>
<p>In both classes, the <code>use()</code> method is an essential part of the <code>Weapon</code> interface's contract. This method provides a way to use the weapon, and its implementation varies between the <code>Bow</code> and <code>Sword</code>.</p>
<p>Here's how we can instantiate the <code>Sword</code> and <code>Bow</code> objects:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Creating and using a Sword object</span>
Sword sword = <span class="hljs-keyword">new</span> Sword();
sword.setName(<span class="hljs-string">"Sword of Power"</span>);
sword.setDamage(<span class="hljs-number">50</span>);
sword.use(); 


<span class="hljs-comment">// Creating and using a Bow object</span>
Bow bow = <span class="hljs-keyword">new</span> Bow();
bow.use();
bow.reload(); <span class="hljs-comment">// Reload the bow after use</span>
bow.upgrade();
</div></code></pre>
<p>Suppose that players can use their weapon during gameplay.</p>
<ul>
<li>The <code>use</code> method in the <code>Weapon</code> class represents the action of using the weapon, such as swinging a sword or shooting an arrow with a bow.</li>
<li>To incorporate this action into the <code>Player</code> class, we can add a method that allows the player to use their weapon.</li>
</ul>
<p>Here is how the code might look:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> </span>{
    <span class="hljs-keyword">private</span> Weapon weapon;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> health;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> score;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Player</span><span class="hljs-params">(Weapon weapon)</span> </span>{
        <span class="hljs-keyword">this</span>.weapon = weapon;
        <span class="hljs-keyword">this</span>.score = <span class="hljs-number">0</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span><span class="hljs-params">()</span> </span>{
        weapon.use();
    }

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWeapon</span><span class="hljs-params">(Weapon weapon)</span> </span>{
        <span class="hljs-keyword">this</span>.weapon = weapon;
    }

    <span class="hljs-comment">// other parts of the code</span>
}
</div></code></pre>
<p>In this updated code:</p>
<ul>
<li>The <code>Player</code> class now has a method <code>useWeapon()</code>. This method calls the <code>use()</code> method on the <code>weapon</code> object, which is an instance of a class that implements the <code>Weapon</code> interface.</li>
<li>When a player decides to use their weapon, the <code>useWeapon()</code> method will invoke the specific <code>use()</code> method of the weapon they are holding, whether it's a sword, bow, or any other weapon type.</li>
</ul>
<h2 id="abstraction">Abstraction</h2>
<p><strong>Abstraction</strong> in object-oriented design is a process of hiding the implementation details and showing only the essential functionality to the user. It lets you focus on what the object does instead of how it does it.</p>
<p><img src="image-18.png" alt="Alt text"></p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> </span>{
    <span class="hljs-keyword">private</span> Weapon weapon;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span><span class="hljs-params">()</span> </span>{
        weapon.use();
    }

    <span class="hljs-comment">// other parts of the code ...</span>
}
</div></code></pre>
<p>In our game,</p>
<ul>
<li>The <code>Player</code> class interacts with the <code>Weapon</code> interface, not the specific classes that implement this interface.</li>
<li>The <code>Weapon</code> interface provides a high-level understanding of what a weapon should be able to do (i.e., it should be usable), without getting into the specifics of how this is done.</li>
<li>When a player decides to use their weapon, the weapon's <code>use</code> method is called. The <code>Player</code> class doesn't need to know how the <code>use</code> method works for each specific type of weapon. It only needs to know that the <code>use</code> method exists and can be called on the weapon. The specific implementation details of how each type of weapon is used are hidden from the <code>Player</code> class.</li>
</ul>
<h2 id="composition-and-delegation">Composition and Delegation</h2>
<p><strong>Composition</strong> involves composing a class using instances of other classes or interfaces to achieve the desired functionality.</p>
<p><strong>Delegation</strong> is a core concept in composition, where an object handles a request by delegating it to a second helper object (the delegate). This allows distributing responsibilities among different classes and promotes code reuse and flexibility.</p>
<p>For instanace, for the <code>Player</code> class,</p>
<ul>
<li>It stores a reference to a <code>Weapon</code> object and has a method <code>useWeapon()</code> that calls the <code>use()</code> method on the <code>Weapon</code> object.</li>
<li>Instead of the <code>Player</code> class implementing the <code>use()</code> method itself, it delegates this responsibility to the <code>weapon</code> object.</li>
<li>This allows the <code>Player</code> class to use the behavior defined in the <code>Weapon</code> class without needing to know the details of how this behavior is implemented.</li>
</ul>
<h2 id="program-to-an-interface">Program to an interface</h2>
<p>&quot;Program to an interface&quot; is an OO Design principle which suggests that software components should depend on abstraction rather than concrete implementations. This principle promotes decoupling and enhances the flexibility and maintainability of the code.</p>
<p>In the context of the <code>Player</code> and <code>Weapon</code> classes, if Weapon is an interface (or an abstract class), and the <code>Player</code> class uses the Weapon interface rather than a specific weapon implementation.  This means you can pass any object that implements <code>Weapon</code> to <code>Player</code>, making the code more flexible. If you want to introduce a new weapon, you just need to create a new class that implements Weapon, and Player can use it without any changes.</p>
<h2 id="polymorphism">Polymorphism</h2>
<p>Polymorphism, a core principle in object-oriented programming (OOP), is derived from the Greek words meaning &quot;many shapes.&quot;</p>
<ul>
<li>It refers to the ability of a variable, function, or object to assume various forms.</li>
<li>This technique allows for writing versatile code that does not have to be aware of the specific subtype of an object, as long as the object adheres to a defined interface.</li>
</ul>
<p>In our case, with both <code>Bow</code> and <code>Sword</code> classes implementing the <code>Weapon</code> interface, they demonstrate polymorphism by being used interchangeably wherever a <code>Weapon</code> type is expected. Both classes possess a <code>use()</code> method, albeit with differing implementations:</p>
<pre class="hljs"><code><div>Weapon bow = <span class="hljs-keyword">new</span> Bow();
Weapon sword = <span class="hljs-keyword">new</span> Sword();

<span class="hljs-comment">// Using the weapons</span>
bow.use();
sword.use();
</div></code></pre>
<p>The benefit of this approach is the creation of flexible and extendable code. It allows for the introduction of varied behaviors (like different ways of using weapons) depending on the type of object at runtime, without the need for changing existing code.</p>
<p>For example, introducing a new weapon type like a <code>Hammer</code> is straightforward. The <code>Hammer</code> class, implementing the <code>Weapon</code> interface, can define its unique version of the <code>use()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hammer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Weapon</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> damage;
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-comment">// Constructor and other methods ...</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> </span>{
        System.out.println(name + <span class="hljs-string">" smashes causing "</span> + damage + <span class="hljs-string">" damage."</span>);
    }
}
</div></code></pre>
<p>Now, the <code>Hammer</code> can be seamlessly integrated into the game and used by the <code>Player</code> class. A <code>Hammer</code> object can be created and set as the player's weapon. There is no need to modify the <code>Player</code> class or any other existing code.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Create a new Hammer object</span>
Hammer hammer = <span class="hljs-keyword">new</span> Hammer();
...
player.setWeapon(hammer);
</div></code></pre>
<p>Polymorphism enables the <code>Player</code> class to interact with any object that implements the <code>Weapon</code> interface, regardless of the weapon's specific type or the details of its <code>use()</code> method. This leads to a more maintainable, scalable, and flexible codebase, where new functionalities can be added with minimal changes.</p>
<h2 id="uml-class-diagrams">UML Class Diagrams</h2>
<p>In UML (Unified Modeling Language) class diagrams, the relationships and structures of classes in an object-oriented system can be graphically represented.</p>
<ul>
<li><strong>Classes</strong>: Represented by rectangles divided into three parts: the top part for the class name, the middle part for attributes, and the bottom part for methods.</li>
<li><strong>Relationships</strong>: Different types of lines and arrows are used to depict various relationships like inheritance, association,  interface implementation (realization), and association.</li>
</ul>
<p><img src="image-6.png" alt="Alt text"></p>
<p>Types of relationship in OO:</p>
<ol>
<li><strong>Is-a Relationship</strong> (Inheritance/Generalization):</li>
</ol>
<ul>
<li>This is depicted by a line with a closed, unfilled arrowhead pointing from the subclass to the superclass.</li>
<li>In our game, <code>Warrior</code> and <code>Mage</code> are subclasses of <code>Player</code>. This is an is-a relationship because a <code>Warrior</code> is-a <code>Player</code>, and a <code>Mage</code> is-a <code>Player</code>.</li>
</ul>
<ol start="2">
<li><strong>Has-a Relationship</strong> (Association/Aggregation/Composition):</li>
</ol>
<ul>
<li>This represents that an object of one class 'owns' or 'uses' objects of another class.</li>
<li>In our game, the <code>Player</code> class has a <code>Weapon</code>. This is a has-a relationship because a <code>Player</code> has-a <code>Weapon</code>.</li>
</ul>
<ol start="3">
<li><strong>Behaves-like-a</strong> (Interface Implementation):</li>
</ol>
<ul>
<li>This is depicted by a dashed line with a closed, unfilled arrowhead pointing from the implementing class to the interface.</li>
<li>In our game, <code>Bow</code> and <code>Sword</code> implement the <code>Weapon</code> interface.</li>
</ul>
<h2 id="abstract-class">Abstract class</h2>
<p>Abstract class vs. Interface</p>
<ul>
<li>An interface is used to group related methods with empty bodies. It specifies &quot;what&quot; a class must do, but not &quot;how.&quot;</li>
<li>An abstract class, in contrast, can have a mix of methods with and without implementations. It can provide a common base of functionality for subclasses. It may also define attributes that a common to subclasses.</li>
<li>Both interfaces and abstract classes abstract the concept and provide polymorphism.</li>
</ul>
<p>For instance, we can instead define the abstract class <code>Weapon</code> to define a concrete method <code>getDamage()</code>, while still requiring subclasses to implement the abstract <code>use()</code> method.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Weapon</span> </span>{
  <span class="hljs-keyword">int</span> damage;
  <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span></span>;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDamage</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.damage;
  }
}
</div></code></pre>
<p>Any subclass of <code>Weapon</code> needs to extend the abstract class rather than implementing it like an interface. For instance, a <code>Bow</code> class extending the <code>Weapon</code> abstract class would inherit the <code>getDamage()</code> method and must provide its own implementation of the <code>use()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Weapon</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> damage)</span> </span>{
        <span class="hljs-keyword">super</span>(damage);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// Shooting arrows</span>
    }
}
</div></code></pre>
<p>Here is the UML diagram.</p>
<p><img src="image-17.png" alt="Alt text"></p>
<h1 id="the-solid-principle">The SOLID Principle</h1>
<p>SOLID is an acronym representing five key design principles intended to make software designs more understandable, flexible, and maintainable.</p>
<ol>
<li><strong>Single Responsibility Principle (SRP):</strong> A class should have only one reason to change.</li>
<li><strong>Open/Closed Principle (OCP):</strong> Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.</li>
<li><strong>Liskov Substitution Principle (LSP):</strong> Objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program.</li>
<li><strong>Interface Segregation Principle (ISP):</strong> Clients should not be forced to depend on interfaces they do not use. It is better to have multiple specific interfaces rather than a single general-purpose interface.</li>
<li><strong>Dependency Inversion Principle (DIP):</strong> High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details, but details should depend on abstractions.</li>
</ol>
<p>These principles serve as guidelines for designing software systems that are modular, maintainable, and easily extensible.</p>
<h2 id="single-responsibility-principle-srp">Single Responsibility Principle (SRP)</h2>
<p>The Single Responsibility Principle requires that a class should have only one reason to change, meaning it should have only one job or responsibility.</p>
<p>In our RPG game, we ensure each class has a single responsibility.</p>
<ul>
<li>The <code>Weapon</code> class is only responsible for weapon-related attributes and behaviors. It should not include logic for saving game state or managing player health.</li>
<li>The <code>Player</code> class is responsible for player-related behaviors. It's not concerned with how a weapon is used; it only knows that it can use a weapon.</li>
</ul>
<p>By delegating the responsibility of using a weapon to the Weapon class, the <code>Player</code> class adheres to the SRP. If the way a weapon is used needs to change, you would modify the <code>Weapon</code> class, not the <code>Player</code> class. This separation of concerns leads to more maintainable and flexible code.</p>
<h2 id="openclosed-principle-ocp">Open/Closed Principle (OCP)</h2>
<p>The Open/Closed Principle states that software entities should be open for extension, but closed for modification. This means creating modules that can be extended without altering their existing code.</p>
<p>In our game,when introducing new weapon types like <code>MagicWand</code>, instead of modifying the existing <code>Weapon</code> class, we may extend it to support new types of weapons. This approach allows for adding new functionalities without changing the existing code.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> </span>{
    Weapon weapon;
    <span class="hljs-comment">// Rest of the code...</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWeapon</span><span class="hljs-params">(Weapon weapon)</span> </span>{
        <span class="hljs-keyword">this</span>.weapon = weapon;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span><span class="hljs-params">()</span> </span>{
        weapon.use();
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Weapon</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">upgrade</span><span class="hljs-params">()</span></span>;
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MagicWand</span> <span class="hljs-title">implement</span> <span class="hljs-title">Weapon</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> magicPower;

    <span class="hljs-comment">// Magic wand specific methods...</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">use</span> <span class="hljs-params">()</span></span>{
        System.out.println(<span class="hljs-string">"Casting a spell"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">upgrade</span><span class="hljs-params">()</span> </span>{
        magicPower += <span class="hljs-number">10</span>;
    }
}
</div></code></pre>
<pre class="hljs"><code><div>Weapon my_weapon = <span class="hljs-keyword">new</span> MagicWand();
player.setWeapon(my_weapon);
player.useWeapon();
</div></code></pre>
<h2 id="liskov-substitution-principle-lsp">Liskov Substitution Principle (LSP)</h2>
<p>According to LSP, objects of a superclass should be replaceable with objects of its subclasses without affecting the application. In the context of the Weapon class and its potential subclasses, to adhere to LSP, any subclass of <code>Weapon</code> should be able to be used wherever a <code>Weapon</code> object is expected, without causing any issues or changes in behavior.</p>
<p>For instance, suppose we add an method to attack a monster. We should be able to use any subclass of the <code>Weapon</code> interface to attack the <code>Monster</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monster</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> health;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attack</span><span class="hljs-params">(Weapon weapon)</span> </span>{
        <span class="hljs-keyword">int</span> damage = weapon.getDamage();
        takeDamage(damage);
    }
    
    <span class="hljs-comment">//other codes ...</span>
}
</div></code></pre>
<h2 id="interface-segregation-principle-isp">Interface Segregation Principle (ISP)</h2>
<p>The Interface Segregation Principle states that no client should be forced to depend on methods it does not use.</p>
<ul>
<li><strong>Segregate Interfaces</strong>: Instead of having a single large interface for all actions a character can perform, break it down into smaller interfaces. For example, <code>Attackable</code> for attack actions, <code>Talkable</code> for talking actions, etc.</li>
<li><strong>Implement Only What Is Needed</strong>: Each type of character (like Monster, Player, NPC) should only implement the interfaces that are relevant to it. For instance, a Monster might only implement <code>Attackable</code> and not <code>Talkable</code>.</li>
</ul>
<p>This approach makes your code more flexible and maintainable. If you need to add a new type of action, you can create a new interface without modifying existing interfaces or classes that don’t need that action.</p>
<h2 id="dependency-inversion-principle-dip">Dependency Inversion Principle (DIP)</h2>
<h3 id="saving-the-game">Saving the game</h3>
<p>We will start with a <code>GameSaver</code> class for saving the state of a game. Consider the following implementation of the class.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameSaver</span> </span>{
    <span class="hljs-keyword">private</span> MySQLDatabase database;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GameSaver</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.database = <span class="hljs-keyword">new</span> MySQLDatabase();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveGame</span><span class="hljs-params">(GameState gameState)</span> </span>{
        database.saveGame(gameState);
    }
}
</div></code></pre>
<p>To save the game, we may execute:</p>
<pre class="hljs"><code><div>GameSaver gameSaver = <span class="hljs-keyword">new</span> GameSaver();
gameSaver.saveGame(gameState);
</div></code></pre>
<h3 id="cohesion-vs-coupling">Cohesion vs. Coupling</h3>
<p><strong>Cohesion</strong> is used to indicate the degree to which a class has a single, well-focused purpose.</p>
<p><strong>Coupling</strong> is the degree to which one class knows about another class.</p>
<ul>
<li>If a class has a high degree of knowledge about another class, we say that these classes are &quot;tightly coupled&quot;.</li>
<li>It makes the system harder to maintain and modify.</li>
</ul>
<p>Good OO design should be loosely coupled and highly cohesive.</p>
<ul>
<li>Easier to develop</li>
<li>Easier to maintain</li>
<li>Easier to add new features</li>
<li>Less fragile.</li>
</ul>
<p>In the previous <code>GameSaver</code> example, the <code>MySQLDatabase</code> instance represents a dependency of the <code>GameSaver</code> class.</p>
<ul>
<li>The <code>GameSaver</code> class directly instantiates a `MySQLDatabase`` object in its constructor and uses this object to save the game state.</li>
<li><code>GameSaver</code> class is tightly coupled with the <code>MySQLDatabase</code> class.</li>
</ul>
<p>The problem with this design is that if you want to change the type of database (for example, from MySQL to MongoDB), you would need to modify the <code>GameSaver</code> class. For instance,</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameSaver</span> </span>{
    <span class="hljs-keyword">private</span> MongoDB database;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GameSaver</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.database = <span class="hljs-keyword">new</span> MongoDB();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveGame</span><span class="hljs-params">()</span> </span>{
        database.saveGame(GameState gameState);
    }
}
</div></code></pre>
<p>You have to modify the <code>GameSaver</code> class every time you want to change the type of database used by the class. A better approach would be to decouple <code>GameSaver</code> from the specific database classes using the &quot;Dependency Inversion Principle&quot;.</p>
<p>A &quot;dependency&quot; here here refers to an object that can be used as a service. In this example, the GameServer depends on the concrete implementation of the databases (e.g. MySQLDatabase or MongoDB).</p>
<p><img src="image-13.png" alt="Alt text"></p>
<h3 id="dependency-inversion-principle-dip">Dependency Inversion Principle (DIP)</h3>
<p>The DIP states that high-level modules should not depend on low-level modules. Both should depend on abstractions.</p>
<p><img src="image-14.png" alt="Alt text"></p>
<p>In the context of the <code>GameSaver</code> example, GameSaver is a high-level module and Database (<code>MySQLDatabase</code> and <code>MongoDB</code> classes) are  a low-level module.</p>
<ul>
<li>By having <code>GameSaver</code> depend on the Database interface (an abstraction), rather than on concrete Database implementations (MySQLDatabase or MongoDB), we are adhering to the Dependency Inversion Principle.</li>
<li>This makes <code>GameSaver</code> more flexible and easier to maintain, as it can work with any type of database that implements the Database interface.</li>
</ul>
<p><strong>Dependency Injection</strong> is a technique that implements the <em>Dependency Inversion Principle</em>, where an object receives other objects it depends on, rather than creating them itself. These dependencies are usually provided through a constructor, a setter, or some kind of factory method.</p>
<p>First, we define a <code>Database</code> interface, which  declares a method <code>saveGame(GameState gameState)</code>, which is expected to be implemented by any class that implements this interface. The `saveGame`` method is intended to save a game state to a database.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Database</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveGame</span><span class="hljs-params">(GameState gameState)</span></span>;
}
</div></code></pre>
<p>Next, two classes <code>MySQLDatabase</code> and <code>MongoDB</code> are defined, both of which implement the <code>Database</code> interface. This means they provide their own implementations of the <code>saveGame</code> method.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySQLDatabase</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Database</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveGame</span><span class="hljs-params">(GameState gameState)</span> </span>{
        <span class="hljs-comment">// Implementation for saving game to a MySQL database</span>
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MongoDB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Database</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveGame</span><span class="hljs-params">(GameState gameState)</span> </span>{
        <span class="hljs-comment">// Implementation for saving game to a MnogoDB database</span>
    }
}
</div></code></pre>
<p>Let's improve the design of the <code>GameSever</code> class.</p>
<ul>
<li>The specific type of <code>Database</code> (e.g., <code>MySQLDatabase</code> or <code>MongoDB</code>) is provided to the <code>GameSaver</code> class through its constructor.</li>
<li>The <code>GameSaver</code> class doesn't need to know the specific type of <code>Database</code> it's working with. Instead, it works with any object that implements the <code>Database</code> interface.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameSaver</span> </span>{
    <span class="hljs-keyword">private</span> Database database;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GameSaver</span><span class="hljs-params">(Database database)</span> </span>{
        <span class="hljs-keyword">this</span>.database = database;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveGame</span><span class="hljs-params">()</span> </span>{
        database.saveGame();
    }
}
</div></code></pre>
<p>By passing different implementation of <em>Database</em> interface to the <code>GameSaver</code> constructor, you can save the game  using different types of databases without modifying the <code>GameSaver</code> class.</p>
<p>For instance, for using the MySQL database,</p>
<pre class="hljs"><code><div>Database mySqlDatabase = <span class="hljs-keyword">new</span> MySQLDatabase();
GameSaver gameSaver = <span class="hljs-keyword">new</span> GameSaver(mySqlDatabase);
gameSaver.saveGame(); <span class="hljs-comment">// Save the game state using MySQLDatabase</span>
</div></code></pre>
<p>If we want to change to MongoDB, there is no need modify existing classes (e.g. <code>GameSaver</code>)</p>
<pre class="hljs"><code><div>Database mongoDB = <span class="hljs-keyword">new</span> MongoDB();
GameSaver gameSaver = <span class="hljs-keyword">new</span> GameSaver(mongoDB);
gameSaver.saveGame(); <span class="hljs-comment">// Save the game state using MongoDB</span>
</div></code></pre>
<p>The improved design allows for flexibility in choosing the type of database to use for saving the game. Any class that implements the <code>Database</code> interface can be used, making it easy to switch between different types of databases.</p>
<p>Types of Dependency Injection:</p>
<p><strong>Constructor Injection</strong>:
In this type, the dependencies are provided through a class constructor. This is the most common type of DI and is typically used when the dependency is required for the class to function.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameSaver</span> </span>{
    <span class="hljs-keyword">private</span> Database database;

    <span class="hljs-comment">//The databse object is injected through this constructor</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GameSaver</span><span class="hljs-params">(Database database)</span> </span>{
        <span class="hljs-keyword">this</span>.database = database;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveGame</span><span class="hljs-params">(GameState gameState)</span> </span>{
        database.saveGame(gameState);
    }
}
</div></code></pre>
<p>A concrete <code>Database</code> object is injected from outside when the <code>GameSaver</code> object is instantiated.</p>
<pre class="hljs"><code><div>Database mySqlDatabase = <span class="hljs-keyword">new</span> MySQLDatabase();
GameSaver gameSaver = <span class="hljs-keyword">new</span> GameSaver(mySqlDatabase);
</div></code></pre>
<p><strong>Setter Injection</strong></p>
<p>In this type of dependency injection, the client exposes a setter method that the injector uses to inject the dependency. This is typically used when the dependency is optional.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameSaver</span> </span>{
   <span class="hljs-keyword">private</span> Database database;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDatabase</span><span class="hljs-params">(Database database)</span> </span>{
       <span class="hljs-keyword">this</span>.database = database;
   }

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveGame</span><span class="hljs-params">(GameState gameState)</span> </span>{
       <span class="hljs-keyword">if</span>(database != <span class="hljs-keyword">null</span>) {
           database.saveGame(gameState);
       }
   }
}
</div></code></pre>
<p>The <code>GameServer</code> class first created. The setter method is then called to inject the concrete <code>Database</code> object.</p>
<pre class="hljs"><code><div>Database mySqlDatabase = <span class="hljs-keyword">new</span> MySQLDatabase();
GameSaver gameSaver = <span class="hljs-keyword">new</span> GameSaver();
gameSaver.setDatabase(mySqlDatabase);
</div></code></pre>
<h1 id="additional-topics-related-to-oo">Additional topics related to OO</h1>
<h2 id="multiple-inheritance">Multiple Inheritance</h2>
<p>Java does not support multiple inheritance. Multiple inheritance is a language feature that allows a class to inherit from multiple parent classes. While it can provide flexibility and code reuse, it also introduces challenges, one of which is the &quot;Diamond Problem&quot; or &quot;Diamond Inheritance Problem.&quot;</p>
<p><img src="image-15.png" alt="Alt text"></p>
<p>The Diamond Problem occurs when a class inherits from two or more classes that have a common base class</p>
<ul>
<li>In the example above, the <code>MagicKnight</code> class inherits from both the <code>Warrior</code> and <code>Mage</code> classes, which themselves inherit from the <code>Character</code> class. This creates a diamond-shaped inheritance hierarchy.</li>
<li>The issue arises when both the <code>Warrior</code> and <code>Mage</code> classes define their own implementation of the <code>attack</code> method, which overrides the default implementation in the <code>Character</code> class. In the <code>MagicKnight</code> class, there is ambiguity about which <code>attack</code> method should be used. Should it use the <code>attack</code> implementation from <code>Warrior</code> or <code>Mage</code>?</li>
</ul>
<p>The Diamond Problem leads to code ambiguity and potential conflicts. To avoid such issues, languages such as Java often promote alternative approaches like interfaces or composition, which provide a more flexible and manageable way to achieve code reuse and extensibility without the problems associated with multiple inheritance.</p>
<h2 id="inheritance-and-its-problems">Inheritance and Its Problems</h2>
<p><strong>Inheritance</strong> is a mechanism where a new class (derived or child class) extends an existing class (base or parent class). It’s often used to express an &quot;is-a&quot; relationship between the base and derived class. For instance, in a RPG game, you might have a base class <code>Character</code> and derived classes like <code>Player</code>, <code>Monster</code>, and <code>NPC</code>.</p>
<p><strong>Base Class: <code>Character</code></strong>
This is the base class representing a general character in the RPG game.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Character</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-comment">//other attributes</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attack</span><span class="hljs-params">(Character target)</span> </span>{
        System.out.println(name + <span class="hljs-string">" attacks."</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">talk</span><span class="hljs-params">()</span> </span>{
        System.out.println(name + <span class="hljs-string">" talks."</span>);
    }
}
</div></code></pre>
<p><code>Player</code> is a subclass of <code>Character</code> that inherits and utilizes the <code>attack</code> and <code>talk</code> methods without modification. This class signifies that players in the game can both attack and talk.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Character</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attack</span><span class="hljs-params">(Character target)</span> </span>{
        <span class="hljs-keyword">super</span>.attack(target);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">talk</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"The player is talking"</span>)
    }
}
</div></code></pre>
<p><code>Monster</code> is another subclass of <code>Character</code>. While it retains the attacking capability (inherited from <code>Character</code>), it overrides the <code>talk</code> method to throw an exception, indicating that monsters in the game are not capable of talking.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monster</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Character</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attack</span><span class="hljs-params">(Character target)</span> </span>{
        <span class="hljs-keyword">super</span>.attack(target);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">talk</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"Monsters cannot talk."</span>);
    }
}
</div></code></pre>
<p><code>NPC</code> (Non-Player Character) extends <code>Character</code> and is designed to talk but not to attack. The <code>talk</code> method is used as inherited, but the <code>attack</code> method is overridden to throw an exception, reflecting that NPCs are not designed for combat in the game.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NPC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Character</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">talk</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"NPC is talking"</span>)
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attack</span><span class="hljs-params">(Character target)</span> </span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"NPCs cannot attack."</span>);
    }
}
</div></code></pre>
<p>While inheritance is a commonly used mechanism in object-oriented programming for sharing behavior among classes, it can lead to several issues, including the violation of the Liskov Substitution Principle (LSP):</p>
<ol>
<li>
<p><strong>Rigidity</strong>: Inheritance creates a tight coupling between the base class and its subclasses. Any changes made to the base class can have unintended ripple effects on all of its derived classes. This rigidity can make maintenance and future updates more challenging.</p>
</li>
<li>
<p><strong>Lack of Flexibility</strong>: Subclasses inherit all properties and methods of the base class, including potentially irrelevant or unnecessary ones. This can lead to a bloated and less optimal design, reducing the flexibility of the subclass to operate independently of its parent.</p>
</li>
<li>
<p><strong>Violation of the Liskov Substitution Principle (LSP)</strong>:</p>
</li>
</ol>
<ul>
<li>LSP states that objects of a superclass should be replaceable with objects of its subclasses without altering the correctness of the program.</li>
<li>When subclasses cannot use all the methods inherited from the parent class without modification or when they need to throw exceptions for certain methods (as seen in the <code>Monster</code> and <code>NPC</code> classes in the RPG example), it violates LSP.</li>
<li>In the given example, replacing a <code>Character</code> object with a <code>Monster</code> or <code>NPC</code> object could lead to runtime errors, as these subclasses do not fully support all behaviors of the base class.</li>
</ul>
<ol start="4">
<li><strong>Reusability Issues</strong>: The need to inherit from a base class to reuse behavior can limit the reusability of code. Subclasses are forced to inherit all behaviors, even if they only need a subset, which can lead to inefficient and unnecessary code duplication.</li>
</ol>
<p><img src="image-19.png" alt="Alt text"></p>
<h2 id="using-interface-to-model-behaviors">Using Interface to model behaviors</h2>
<p>We can define interface classes o address the limitations of inheritance</p>
<ul>
<li>An interface in Java is a contract that defines a set of methods without implementing them. Implementing an interface allows a class to become more formal about the behavior it promises to provide.</li>
<li>In our RPG example, we can define interfaces like <code>Attackable</code> and <code>Talkable</code> instead of using a base <code>Character</code> class.</li>
</ul>
<p><img src="image-16.png" alt="Alt text"></p>
<p>We first define the interface to model the behavior of different types of characters.</p>
<ul>
<li><code>Attackable</code> is an interface with the method <code>attack(Character target)</code>, which define the behavior to attack other characters.</li>
<li><code>Talkable</code> is another interface with the method <code>talk()</code> that represents the ability to talk.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Attackable</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">attack</span><span class="hljs-params">(Character target)</span></span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Talkable</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">talk</span><span class="hljs-params">()</span></span>;
}
</div></code></pre>
<p>The <code>Player</code>  class  implements both <code>Attackable</code> and <code>Talkable</code> interfaces.</p>
<ul>
<li>By implementing <code>Attackable</code>, the <code>Player</code> class provides concrete implementations of the <code>attack</code>  methods</li>
<li>By implementing <code>Talkable</code>, the <code>Player</code> class also provides a concrete implementation of the talk method, giving it the ability to speak.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Attackable</span>, <span class="hljs-title">Talkable</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attack</span><span class="hljs-params">(Character target)</span> </span>{
        System.out.println(<span class="hljs-string">"Player attacks."</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">talk</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"Player is talking."</span>);
    }
}
</div></code></pre>
<p>The <code>Monster</code>  class implements the <code>Attackable</code> interface.</p>
<ul>
<li>It provides concrete implementations of the <code>attack</code> , meaning it can attack other entities and take damage.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monster</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Attackable</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attack</span><span class="hljs-params">(Character target)</span> </span>{
        System.out.println(<span class="hljs-string">"Monster attacks."</span>);
    }
}
</div></code></pre>
<p>The <code>NPC</code> class implements the <code>Talkable</code> interface. It provides an implementation of the talk method, which means an NPC can engage in conversation.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NPC</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Talkable</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">talk</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"NPC is talking."</span>);
    }
}
</div></code></pre>
<p>Here is an example of using the interface.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Game</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Talkable player = <span class="hljs-keyword">new</span> Player();
        Talkble npc = <span class="hljs-keyword">new</span> NPC();
        npc.talk();
        player.talk();
    }
}
</div></code></pre>
<p>By using interfaces instead of inheritance provides enhanced flexibility, modularity, and maintainability.</p>
<ul>
<li>Classes like <code>Player</code>, <code>Monster</code>, and <code>NPC</code> can implement multiple interfaces, allowing for a mix-and-match approach to functionality.</li>
<li>This design enables classes to implement only the behaviors they need, avoiding the constraints and potential complexity of a rigid inheritance hierarchy.</li>
<li>It leads to a system that is easier to extend and adapt, with loosely coupled, interchangeable components.</li>
</ul>
<h2 id="testing-with-mock-objects">Testing with Mock objects</h2>
<p>In unit testing , mock objects can be used to imitate the behavior of external dependency in a controlled manner. This is useful when testing functions that interact with files, databases, or external systems. Direct testing of functions that integrate with databases can be slow and unreliable.</p>
<p>The Dependency Inversion Principle (DIP) enhances the testability of the <code>GameSaver</code> class by facilitating the injection of mock database objects during tests. This mock object replicates the functionality of a genuine <code>Database</code>, minus the side effects like real data storage. As a result, the <code>GameSaver</code> class can be tested in isolation, removing the need to set up and dismantle a real database for each test.</p>
<p>Let's consider the following <code>MockDatabase</code> class which simulates the error condition of failing to connect to the database.</p>
<ul>
<li>The <code>MockDatabase</code> serves as a simulated <code>Database</code> object for testing.</li>
<li>Throws a <code>DatabaseConnectionException</code> when <code>simulateFailure</code> is true, emulating a failed database connection.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockDatabase</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Database</span> </span>{
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveGame</span><span class="hljs-params">(GameState gameState)</span> </span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DatabaseConnectionException(<span class="hljs-string">"Failed to connect to database."</span>);
    }

}
</div></code></pre>
<p>Here is a sample test case when there is database connection failure to  test the error-handling abilities of the <code>GameSaver</code> class in JUnit.</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSaveGameFailure</span><span class="hljs-params">()</span> </span>{
    MockDatabase mockDatabase = <span class="hljs-keyword">new</span> MockDatabase();
    GameSaver gameSaver = <span class="hljs-keyword">new</span> GameSaver(mockDatabase);
    GameState mockGameState = <span class="hljs-keyword">new</span> MockGameState();
    
    gameSaver.saveGame(mockGameState);

    <span class="hljs-comment">// check if the gameSaver handles the error gracefully ...</span>
}
</div></code></pre>
<p>By using mock databases, we can isolate and assess our application logic without involving real database operations. The advantages include:</p>
<ul>
<li>Increased speed of the unit test by avoiding the latency of actual database transactions.</li>
<li>Simplified testing by allowing the easy simulation of various database states.</li>
<li>Reliable and consistent outcomes, not influenced by external elements such as network interruptions or database downtimes.</li>
</ul>
<h3 id="inversion-of-control-ioc-container">Inversion of Control (IoC) container</h3>
<p>In frameworks like Java Spring, the creation and management of dependencies are delegated to an Inversion of Control (IoC) container.</p>
<ul>
<li>Responsible for instantiating, configuring, and assembling the objects in your application.</li>
<li>Simplifies the management of dependencies and promotes a coding style that leads to more modular, understandable, and testable code.</li>
</ul>
<p>In Spring boot, you can define your configuration in <code>application.yaml</code> (or <code>application.yml</code>) files. For example, if you have different configurations for MySQL and MongoDB, you might define two files: <code>application-mysql.yml</code> and <code>application-mongodb.yml</code>.</p>
<p>Here's an example of what <code>applcation-mysql.yml</code> might look like:</p>
<pre class="hljs"><code><div><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">datasource:</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mydatabase</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">myusername</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">mypassword</span>
</div></code></pre>
<p>Here is an example of <code>application-mongodb.yml</code>:</p>
<pre class="hljs"><code><div><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">data:</span>
    <span class="hljs-attr">mongodb:</span>
      <span class="hljs-attr">uri:</span> <span class="hljs-string">mongodb://localhost:27017/mydatabase</span>
</div></code></pre>
<p>You can choose which profile (and thus which configuration file) to use when launching the application  by setting the <code>spring.profiles.active</code> property. For intsance,</p>
<ol>
<li>To launch your app with MySQL, you may execute</li>
</ol>
<pre class="hljs"><code><div>./mvnw spring-boot:run -Dspring-boot.run.profiles=mysql
</div></code></pre>
<ol start="2">
<li>To launch your app with MongoDB, you may execute</li>
</ol>
<pre class="hljs"><code><div>./mvnw spring-boot:run -Dspring-boot.run.profiles=mongodb
</div></code></pre>
<p>The Inversion of Control (IoC) container in Spring Boot will instantiate the corresponding object and inject it into the application. This automatic creation, configuration, and injection of dependencies is handled by the Spring Framework's IoC container. By outsourcing the creation and management of dependencies to the IoC container,it allows developers to focus on the core functionality of their application rather than the details of object creation and management.Your application components can remain focused on their core responsibilities, leading to cleaner and more maintainable code.</p>

</body>
</html>
